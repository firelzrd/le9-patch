#!/usr/bin/env python3
"""mem2log"""

from argparse import ArgumentParser
from ctypes import CDLL
from signal import SIGHUP, SIGINT, SIGQUIT, SIGTERM, signal
from sys import exit
from time import sleep


def log(msg):
    """
    """
    print(msg)
    if separate_log:
        logging.info(msg)


def mlockall():
    """
    """
    MCL_CURRENT = 1
    MCL_FUTURE = 2
    MCL_ONFAULT = 4

    libc = CDLL(None, use_errno=True)
    result = libc.mlockall(MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT)

    if result != 0:
        result = libc.mlockall(MCL_CURRENT | MCL_FUTURE)
        if result != 0:
            log('WARNING: cannot lock process memory: [Errno {}]'.format(
                result))
        else:
            log('Process memory locked with MCL_CURRENT | MCL_FUTURE')
    else:
        log('Process memory locked with MCL_CURRENT | MCL_FUTURE | MCL_'
            'ONFAULT')


def check_meminfo():
    """
    """
    with open('/proc/meminfo') as f:
        for n, line in enumerate(f):

            # MA
            if n == mem_available_index:
                mem_available = int(line.split(':')[1][:-4])
                continue

            # BU
            if n == buffers_index:
                buffers = int(line.split(':')[1][:-4])
                continue

            # CA
            if n == cached_index:
                cached = int(line.split(':')[1][:-4])
                continue

            # AA
            if n == active_anon_index:
                active_anon = int(line.split(':')[1][:-4])
                continue

            # IA
            if n == inactive_anon_index:
                inactive_anon = int(line.split(':')[1][:-4])
                continue

            # AF
            if n == active_file_index:
                active_file = int(line.split(':')[1][:-4])
                continue

            # IF
            if n == inactive_file_index:
                inactive_file = int(line.split(':')[1][:-4])
                continue

            # ST
            if n == swap_total_index:
                swap_total = int(line.split(':')[1][:-4])
                continue

            # SF
            if n == swap_free_index:
                swap_free = int(line.split(':')[1][:-4])
                continue

            # SH
            if n == shmem_index:
                shmem = int(line.split(':')[1][:-4])
                continue

            # SR
            if n == sreclaimable_index:
                sreclaimable = int(line.split(':')[1][:-4])
                continue

    return (
        mem_available,
        buffers,
        cached,
        active_anon,
        inactive_anon,
        active_file,
        inactive_file,
        swap_total,
        swap_free,
        shmem,
        sreclaimable)


def percent(num):
    """Interprete num as percentage."""
    return round(num * 100, 1)


def signal_handler(signum, frame):
    """
    """
    def signal_handler_inner(signum, frame):
        pass

    for i in sig_list:
        signal(i, signal_handler_inner)

    log('--')

    log('Got the {} signal'.format(
        sig_dict[signum]))

    log('Peak values:')

    log('  MA: min {}, max {}'.format(
        round(min_dict['MA'] / 1024, 1),
        round(max_dict['MA'] / 1024, 1)))

    log('  BU: min {}, max {}'.format(
        round(min_dict['BU'] / 1024, 1),
        round(max_dict['BU'] / 1024, 1)))

    log('  CA: min {}, max {}'.format(
        round(min_dict['CA'] / 1024, 1),
        round(max_dict['CA'] / 1024, 1)))

    log('  AA: min {}, max {}'.format(
        round(min_dict['AA'] / 1024, 1),
        round(max_dict['AA'] / 1024, 1)))

    log('  IA: min {}, max {}'.format(
        round(min_dict['IA'] / 1024, 1),
        round(max_dict['IA'] / 1024, 1)))

    log('  AF: min {}, max {}'.format(
        round(min_dict['AF'] / 1024, 1),
        round(max_dict['AF'] / 1024, 1)))

    log('  IF: min {}, max {}'.format(
        round(min_dict['IF'] / 1024, 1),
        round(max_dict['IF'] / 1024, 1)))

    log('  SF: min {}, max {}'.format(
        round(min_dict['SF'] / 1024, 1),
        round(max_dict['SF'] / 1024, 1)))

    log('  SU: min {}, max {}'.format(
        round(min_dict['SU'] / 1024, 1),
        round(max_dict['SU'] / 1024, 1)))

    log('  SH: min {}, max {}'.format(
        round(min_dict['SH'] / 1024, 1),
        round(max_dict['SH'] / 1024, 1)))

    log('  SR: min {}, max {}'.format(
        round(min_dict['SR'] / 1024, 1),
        round(max_dict['SR'] / 1024, 1)))

    log('Exit.')

    exit()


parser = ArgumentParser()

parser.add_argument(
    '-i',
    '--interval',
    help="""interval in sec""",
    default=2,
    type=float
)


parser.add_argument(
    '-l',
    '--log',
    help="""path to log file""",
    default=None,
    type=str
)


args = parser.parse_args()
interval = args.interval
log_file = args.log


if log_file is None:
    separate_log = False
else:
    separate_log = True
    import logging

if log_file is not None:
    logstring = 'log file: {}, '.format(log_file)
else:
    logstring = 'log file is not set, '


if separate_log:
    try:
        logging.basicConfig(
            filename=log_file,
            level=logging.INFO,
            format="%(asctime)s: %(message)s")
    except Exception as e:
        print(e)
        exit(1)


if interval <= 0:
    log('error: argument -i/--interval: the value must be greater than 0')
    exit(1)


with open('/proc/meminfo') as f:
    mem_list = f.readlines()


mem_list_names = []

for s in mem_list:
    mem_list_names.append(s.split(':')[0])


mem_available_index = mem_list_names.index('MemAvailable')
buffers_index = mem_list_names.index('Buffers')
cached_index = mem_list_names.index('Cached')
active_anon_index = mem_list_names.index('Active(anon)')
inactive_anon_index = mem_list_names.index('Inactive(anon)')
active_file_index = mem_list_names.index('Active(file)')
inactive_file_index = mem_list_names.index('Inactive(file)')
swap_total_index = mem_list_names.index('SwapTotal')
swap_free_index = mem_list_names.index('SwapFree')
shmem_index = mem_list_names.index('Shmem')
sreclaimable_index = mem_list_names.index('SReclaimable')


mem_total = int(mem_list[0].split(':')[1][:-4])
swap_total = int(mem_list[swap_total_index].split(':')[1][:-4])


sig_list = [SIGTERM, SIGINT, SIGQUIT, SIGHUP]

sig_dict = {
    SIGINT: 'SIGINT',
    SIGQUIT: 'SIGQUIT',
    SIGHUP: 'SIGHUP',
    SIGTERM: 'SIGTERM'
}

for i in sig_list:
    signal(i, signal_handler)


log('Starting mem2log with interval {}s'.format(interval))


if separate_log:
    log('Log file: {}'.format(log_file))


mlockall()

log('All values are in mebibytes')

log(
    'MemTotal: {}, SwapTotal: {}'.format(
        round(mem_total / 1024, 1),
        round(swap_total / 1024, 1)
    )
)

log('--')

log(
    'MA is MemAvailable, '
    'BU is Buffers, '
    'CA is Cached'
)

log(
    'AA is Active(anon), '
    'IA is Inactive(anon), '
    'AF is Active(file), '
    'IF is Inactive(file)'
)

log(
    'SF is SwapFree, '
    'SU is `SwapTotal - SwapFree`, '
    'SH is Shmem, '
    'SR is SReclaimable'
)

log('--')


min_dict = dict()
max_dict = dict()


while True:

    (mem_available, buffers, cached, active_anon, inactive_anon, active_file,
     inactive_file, swap_total, swap_free, shmem, sreclaimable
     ) = check_meminfo()

    swap_used = swap_total - swap_free

    if ('MA' not in max_dict or mem_available > max_dict['MA']):
        max_dict['MA'] = mem_available
    if ('MA' not in min_dict or mem_available < min_dict['MA']):
        min_dict['MA'] = mem_available

    if ('BU' not in max_dict or buffers > max_dict['BU']):
        max_dict['BU'] = buffers
    if ('BU' not in min_dict or buffers < min_dict['BU']):
        min_dict['BU'] = buffers

    if ('CA' not in max_dict or cached > max_dict['CA']):
        max_dict['CA'] = cached
    if ('CA' not in min_dict or cached < min_dict['CA']):
        min_dict['CA'] = cached

    if ('AA' not in max_dict or active_anon > max_dict['AA']):
        max_dict['AA'] = active_anon
    if ('AA' not in min_dict or active_anon < min_dict['AA']):
        min_dict['AA'] = active_anon

    if ('IA' not in max_dict or inactive_anon > max_dict['IA']):
        max_dict['IA'] = inactive_anon
    if ('IA' not in min_dict or inactive_anon < min_dict['IA']):
        min_dict['IA'] = inactive_anon

    if ('AF' not in max_dict or active_file > max_dict['AF']):
        max_dict['AF'] = active_file
    if ('AF' not in min_dict or active_file < min_dict['AF']):
        min_dict['AF'] = active_file

    if ('IF' not in max_dict or inactive_file > max_dict['IF']):
        max_dict['IF'] = inactive_file
    if ('IF' not in min_dict or inactive_file < min_dict['IF']):
        min_dict['IF'] = inactive_file

    if ('SF' not in max_dict or swap_free > max_dict['SF']):
        max_dict['SF'] = swap_free
    if ('SF' not in min_dict or swap_free < min_dict['SF']):
        min_dict['SF'] = swap_free

    if ('SU' not in max_dict or swap_used > max_dict['SU']):
        max_dict['SU'] = swap_used
    if ('SU' not in min_dict or swap_used < min_dict['SU']):
        min_dict['SU'] = swap_used

    if ('SH' not in max_dict or shmem > max_dict['SH']):
        max_dict['SH'] = shmem
    if ('SH' not in min_dict or shmem < min_dict['SH']):
        min_dict['SH'] = shmem

    if ('SR' not in max_dict or sreclaimable > max_dict['SR']):
        max_dict['SR'] = sreclaimable
    if ('SR' not in min_dict or sreclaimable < min_dict['SR']):
        min_dict['SR'] = sreclaimable

    log(
        'MA {}, BU {}, CA {}, AA {}, IA {}, AF {}, IF {}, '
        'SF {}, SU {}, SH {}, SR {}'.format(
            round(mem_available / 1024, 1),
            round(buffers / 1024, 1),
            round(cached / 1024, 1),
            round(active_anon / 1024, 1),
            round(inactive_anon / 1024, 1),
            round(active_file / 1024, 1),
            round(inactive_file / 1024, 1),
            round(swap_free / 1024, 1),
            round(swap_used / 1024, 1),
            round(shmem / 1024, 1),
            round(sreclaimable / 1024, 1)
        ))

    sleep(interval)
